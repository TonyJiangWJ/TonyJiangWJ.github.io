{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"TonyJiang","url":"https://tonyjiangwj.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-09-09T02:37:32.400Z","updated":"2023-09-09T02:37:32.400Z","comments":false,"path":"/404.html","permalink":"https://tonyjiangwj.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-09-09T02:37:32.418Z","updated":"2023-09-09T02:37:32.418Z","comments":false,"path":"books/index.html","permalink":"https://tonyjiangwj.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-09-09T02:37:32.418Z","updated":"2023-09-09T02:37:32.418Z","comments":true,"path":"links/index.html","permalink":"https://tonyjiangwj.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2023-09-09T02:37:32.417Z","updated":"2023-09-09T02:37:32.417Z","comments":false,"path":"about/index.html","permalink":"https://tonyjiangwj.github.io/about/index.html","excerpt":"","text":"很懒，啥也没得介绍"},{"title":"标签","date":"2023-09-09T02:37:32.420Z","updated":"2023-09-09T02:37:32.420Z","comments":false,"path":"tags/index.html","permalink":"https://tonyjiangwj.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-09-09T02:37:32.418Z","updated":"2023-09-09T02:37:32.418Z","comments":false,"path":"categories/index.html","permalink":"https://tonyjiangwj.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-09-09T02:37:32.419Z","updated":"2023-09-09T02:37:32.419Z","comments":false,"path":"repository/index.html","permalink":"https://tonyjiangwj.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"创建插件处理hexo图片","slug":"创建插件处理hexo图片","date":"2023-09-09T08:04:57.000Z","updated":"2023-09-09T08:16:28.015Z","comments":true,"path":"2023/09/09/创建插件处理hexo图片/","link":"","permalink":"https://tonyjiangwj.github.io/2023/09/09/%E5%88%9B%E5%BB%BA%E6%8F%92%E4%BB%B6%E5%A4%84%E7%90%86hexo%E5%9B%BE%E7%89%87/","excerpt":"","text":"背景介绍 在使用markdown编写hexo文档时我们会插入图片，一般需要将它和md文件放在一起，作为一个相对路径插入。但是默认情况下hexo并不能正确识别并处理它的地址 因此需要自己创建一个插件处理它，当前使用的插件参考自 hexo-asset-image 不直接npm install使用它的原因是，这个插件本身也存在些问题，对他进行了些许修改 配置 首先需要修改 _config.yml 文件，打开 post_asset_folder 1post_asset_folder: true 同时需要注意配置好如下两个配置 1234# 部署后的链接url: https://tonyjiangwj.github.io# 网站根目录root: / 在_config.yml中配置插件名称并启用它，我们命名它为asset-image 1234# Extensions## Plugins: https://hexo.io/plugins/asset-image: enable: true 然后创建自己的插件，放在 scripts 目录下 12scripts| --&gt; asset-image.js asset-image.js内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register(&#x27;after_post_render&#x27;, function (data) &#123; var config = hexo.config; if (config.post_asset_folder) &#123; var link = data.permalink; var beginPos = getPosition(link, &#x27;/&#x27;, 3); var appendLink = &#x27;/&#x27;; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. // if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink if (/.*\\/index\\.html$/.test(link)) &#123; // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html // image in xxtitle/ will go to xxtitle/index/ appendLink = &#x27;/index/&#x27;; var endPos = link.lastIndexOf(&#x27;.&#x27;); &#125; else &#123; var endPos = link.lastIndexOf(&#x27;/&#x27;); &#125; console.info &amp;&amp; console.info(&#x27;origin link:&#x27;, link) link = link.substring(beginPos, endPos) + appendLink; console.info &amp;&amp; console.info(&#x27;resolved link:&#x27;, link) var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for (var i = 0; i &lt; toprocess.length; i++) &#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function () &#123; if ($(this).attr(&#x27;src&#x27;)) &#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if (!(/http[s]*.*|\\/\\/.*/.test(src) || /^\\s+\\//.test(src) || /^\\s*\\/uploads|images\\//.test(src))) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function (elem) &#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function (elem) &#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if (srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); let imageSrc = config.root + &#x27;.&#x27; + link + src $(this).attr(&#x27;src&#x27;, imageSrc); console.info &amp;&amp; console.info(&quot;update link as:--&gt;&quot; + imageSrc); &#125; &#125; else &#123; console.info &amp;&amp; console.info(&quot;no src attr, skipped...&quot;); console.info &amp;&amp; console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 我们编写hexo文章的时候，hexo new &#123;文章名称&#125; 会同时创建同名的文件夹，然后插入图片时将文件放到这个文件夹内即可，在markdown中使用相对路径引用它 编写完毕后，执行 hexo clean &amp;&amp; hexo generate 即可重新生成正确的html文件，图片的src将会被替换成正确的地址。","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://tonyjiangwj.github.io/tags/hexo/"}]},{"title":"安装PowerShell7并配置ohmyposh","slug":"安装PowerShell7并配置ohmyposh","date":"2023-09-09T06:13:50.000Z","updated":"2023-09-09T07:59:18.632Z","comments":true,"path":"2023/09/09/安装PowerShell7并配置ohmyposh/","link":"","permalink":"https://tonyjiangwj.github.io/2023/09/09/%E5%AE%89%E8%A3%85PowerShell7%E5%B9%B6%E9%85%8D%E7%BD%AEohmyposh/","excerpt":"","text":"安装PowerShell windowns10默认情况下，自带的PowerShell为5.1，属于很难用的那种。因此需要自己安装最新版的PowerShell7，微软新一代跨平台版本Shell，好用很多。 1、使用winget安装 使用官方推荐方式进行安装，win+x 打开自带的PowerShell，输入如下命令： 1234# 查找当前可用的PowerShell版本winget search Microsoft.PowerShell# 使用winget安装PowerShell，这里安装stable版本winget install --id Microsoft.PowerShell 安装完毕之后，新版的PowerShell为pwsh.exe 默认已经添加到环境变量中 2、替换PowerShell入口 此时需要替换 win+x 和菜单右键中的PowerShell入口，否则使用的还是旧版本的 在windows菜单中搜索 Windows PowerShell 右键文件所在位置，可以看到快捷方式文件，选中后右键修改它的属性，目标修改为 &quot;C:\\Program Files\\PowerShell\\7\\pwsh.exe&quot; ，起始位置可以根据自己习惯修改，为这里改为用户目录：%USERPROFILE% 然后是修改按住shift时右键菜单中的在PowerShell中打开 win+r 运行 regedit，找到 HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\PowerShell\\command 默认情况下command是归属于TrustedInstaller，无法修改当前用户的控制权，需要将所有者进行修改。右键command，点击权限，高级，更改所有者为当前登录用户，完成后点击确定。然后在权限-安全窗口中选中登录用户，勾选上完全控制，点击确认关闭权限窗口。 然后在注册表编辑器中选中 command 在右侧修改 (默认) 的数值数据，将powershell.exe改为pwsh.exe，然后点击确定即可 以上步骤完成后win+x和菜单右键中的PowerShell都将被替换为pwsh.exe也就是最新版本 安装windows终端 控制台其实还是不好看，建议直接安装windows终端 具体教程参考微软的官方说明即可：https://learn.microsoft.com/zh-cn/windows/terminal/install 安装完毕后，在设置中将默认配置文件改为 PowerShell 即可 安装ohmyposh 在MacOS下，我特别喜欢使用zsh+ohmyzsh，有很多好看的主题。现在使用PowerShell也有了类似的插件叫ohmyposh 官方安装指南：https://ohmyposh.dev/docs/installation/windows 1、安装ohmyposh 这里还是推荐使用winget进行安装 1winget install JanDeDobbeleer.OhMyPosh -s winget 安装完毕后需要重启一下终端，载入环境变量 2、安装Nerd Fonts字体 主题中可以使用unicode等字符，因此需要安装相应的字体 有两种方式，推荐直接去这个网站下载：https://www.nerdfonts.com/font-downloads 可以直接预览字体，下载对应的压缩包后解压，选中字体文件右键安装即可 另一种方式是使用官方说明中的命令安装：https://ohmyposh.dev/docs/installation/fonts 1oh-my-posh font install 3、配置字体在windows terminal中 打开windows terminal，在界面中按下 ctrl+shift+, 或者进入设置界面左下角打开JSON文件 编辑其中的内容： 123456789101112131415161718&#123; //... &quot;profiles&quot;: &#123; // 修改这里的defaults,增加font &quot;defaults&quot;: &#123; // 指定字体font.face &quot;font&quot;: &#123; // 我安装的是JetBrainMono字体 &quot;face&quot;: &quot;JetBrainsMono Nerd Font&quot; &#125; &#125;, //... &#125; //...&#125; 在vscode中配置字体 打开vscode设置，搜索 terminal:font family 将使用的字体写入配置中即可 4、配置ohmyposh 配置信息参考官方说明：https://ohmyposh.dev/docs/installation/prompt 打开PowerShell，输入如下命令： 1notepad $PROFILE 编辑文本内容后保存 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json&quot; | Invoke-Expression 修改完毕后执行如下命令使得变更生效 1. $PROFILE 5、配置主题 默认的主题为 jandedobbeleer 我们可以使用如下命令下载并预览所有的可用主题 1Get-PoshThemes 上述命令执行后会在命令行中显示所有的可用主题，按住ctrl和链接可以打开对应的配置文件 在线查看所有主题的地址为：https://ohmyposh.dev/docs/themes 选择想要使用的配置后，将其配置到 $PROFILE 中即可。例如我使用了1_shell.omp.json则修改为如下： 1oh-my-posh init pwsh --config &quot;$env:POSH_THEMES_PATH\\1_shell.omp.json&quot; | Invoke-Expression 默认情况下的主题，可能也不合自己的喜好，可以自己修改它，具体的语法见官网：https://ohmyposh.dev/docs/configuration/general 自定义配置完毕后，可以将当前主题导出到个人目录： 1oh-my-posh config export --output ~/.mytheme.omp.json 其他配置git中文乱码 当使用git status显示中文路径为乱码时，执行以下脚本配置一下 1git config --global core.quotepath false 配置conda，在ohmyposh中显示当前虚拟环境信息 首先需要安装anaconda，请按官网配置或者搜索相关教程即可 在PowerShell中执行 conda init powershell 初始化conda的配置 conda的当前虚拟环境信息会保存到环境变量 CONDA_DEFAULT_ENV 中，因此只需要将它配置到主题文件中即可，在template中配置为 .Env.CONDA_DEFAULT_ENV 参考如下: 12345678910111213&#123; //... &#123; &quot;type&quot;: &quot;session&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#ff9c3f&quot;, &quot;template&quot;: &quot;&#123;&#123; .UserName &#125;&#125;&lt;#faf88e&gt;[&#123;&#123; .Env.CONDA_DEFAULT_ENV &#125;&#125;] &lt;#ffffff&gt;on&lt;/&gt;&quot;, &quot;properties&quot;: &#123; &quot;display_host&quot;: true &#125; &#125;, //...&#125; 自定义后的主题预览如下： 普通目录 git目录 配置默认PowerShell控制台字体 在菜单右键或者win+x直接打开PowerShell时的控制台程序中，显示的字体也需要进行配置，否则会显示得不正常，但是这个控制台并不能完美支持Nerd Font，因此这里推荐安装一下 更纱黑体 github地址：https://github.com/be5invis/Sarasa-Gothic/releases 安装字体之后，win+x打开powershell控制台，点击左上角图标调出菜单点击属性，在字体标签中修改字体为 等距更纱黑体 配置完毕后可以自行调整字体大小为自己喜欢的，预览如下，缺点是无法显示unicode字符： 我当前所使用的自定义主题文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&#123; &quot;$schema&quot;: &quot;https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json&quot;, &quot;version&quot;: 2, &quot;console_title_template&quot;: &quot;&#123;&#123; .Folder &#125;&#125;&quot;, &quot;blocks&quot;: [ &#123; &quot;type&quot;: &quot;prompt&quot;, &quot;alignment&quot;: &quot;left&quot;, &quot;segments&quot;: [ &#123; &quot;type&quot;: &quot;status&quot;, &quot;style&quot;: &quot;plain&quot;, &quot;foreground&quot;: &quot;#A9FFB4&quot;, &quot;foreground_templates&quot;: [ &quot;&#123;&#123; if gt .Code 0 &#125;&#125;#ef5350&#123;&#123; end &#125;&#125;&quot; ], &quot;template&quot;: &quot; \\ue286 &quot;, &quot;properties&quot;: &#123; &quot;always_enabled&quot;: true &#125; &#125;, &#123; &quot;type&quot;: &quot;executiontime&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#a9ffb4&quot;, &quot;template&quot;: &quot; &#123;&#123; .FormattedMs &#125;&#125;s &lt;#ffffff&gt;\\ue601&lt;/&gt;&quot;, &quot;properties&quot;: &#123; &quot;style&quot;: &quot;dallas&quot;, &quot;threshold&quot;: 0 &#125; &#125;, &#123; &quot;type&quot;: &quot;root&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;template&quot;: &quot; \\uf0e7 &quot;, &quot;properties&quot;: &#123; &quot;root_icon&quot;: &quot;\\uf292 &quot; &#125; &#125;, &#123; &quot;type&quot;: &quot;sysinfo&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#94ffa2&quot;, &quot;template&quot;: &quot; &lt;#ffffff&gt;CPU:&lt;/&gt; &#123;&#123; round .PhysicalPercentUsed .Precision &#125;&#125;% &quot; &#125;, &#123; &quot;type&quot;: &quot;sysinfo&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#81ff91&quot;, &quot;template&quot;: &quot;&lt;#ffffff&gt;\\ue266&lt;/&gt; &lt;#ffffff&gt;RAM:&lt;/&gt; &#123;&#123; (div ((sub .PhysicalTotalMemory .PhysicalFreeMemory)|float64) 1073741824.0) &#125;&#125;/&#123;&#123; (div .PhysicalTotalMemory 1073741824.0) &#125;&#125;GB &quot; &#125; ] &#125;, &#123; &quot;type&quot;: &quot;prompt&quot;, &quot;alignment&quot;: &quot;left&quot;, &quot;segments&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#faf88e&quot;, &quot;template&quot;: &quot; &quot; &#125;, &#123; &quot;type&quot;: &quot;session&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#ff9c3f&quot;, &quot;template&quot;: &quot;&#123;&#123; .UserName &#125;&#125;&lt;#faf88e&gt;[&#123;&#123; .Env.CONDA_DEFAULT_ENV &#125;&#125;] &lt;#ffffff&gt;on&lt;/&gt;&quot;, &quot;properties&quot;: &#123; &quot;display_host&quot;: true &#125; &#125;, &#123; &quot;type&quot;: &quot;time&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#bc93ff&quot;, &quot;template&quot;: &quot; &#123;&#123; .CurrentDate | date .Format &#125;&#125; &quot;, &quot;properties&quot;: &#123; &quot;time_format&quot;: &quot;Monday &lt;#ffffff&gt;at&lt;/&gt; 3:04 PM&quot; &#125; &#125;, &#123; &quot;type&quot;: &quot;git&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#ee79d1&quot;, &quot;template&quot;: &quot; &#123;&#123; .UpstreamIcon &#125;&#125;&#123;&#123; .HEAD &#125;&#125;&#123;&#123;if .BranchStatus &#125;&#125; &#123;&#123; .BranchStatus &#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; if .Working.Changed &#125;&#125; \\uf044 &#123;&#123; .Working.String &#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; if and (.Working.Changed) (.Staging.Changed) &#125;&#125; |&#123;&#123; end &#125;&#125;&#123;&#123; if .Staging.Changed &#125;&#125; \\uf046 &#123;&#123; .Staging.String &#125;&#125;&#123;&#123; end &#125;&#125;&#123;&#123; if gt .StashCount 0 &#125;&#125; \\ueb4b &#123;&#123; .StashCount &#125;&#125;&#123;&#123; end &#125;&#125; &quot;, &quot;properties&quot;: &#123; &quot;branch_icon&quot;: &quot;\\ue725 &quot;, &quot;fetch_stash_count&quot;: true, &quot;fetch_status&quot;: true, &quot;fetch_upstream_icon&quot;: true, &quot;fetch_worktree_count&quot;: true &#125; &#125; ], &quot;newline&quot;: true &#125;, &#123; &quot;type&quot;: &quot;prompt&quot;, &quot;alignment&quot;: &quot;left&quot;, &quot;segments&quot;: [ &#123; &quot;type&quot;: &quot;path&quot;, &quot;style&quot;: &quot;diamond&quot;, &quot;foreground&quot;: &quot;#8edbfa&quot;, &quot;trailing_diamond&quot;: &quot;&lt;#8edbfa&gt; &gt; &lt;/&gt;&quot;, &quot;template&quot;: &quot;&#123;&#123; .Path &#125;&#125;&quot;, &quot;properties&quot;: &#123; &quot;folder_icon&quot;: &quot;\\uf07b&quot;, &quot;folder_separator_icon&quot;: &quot;/&quot;, &quot;home_icon&quot;: &quot;home&quot;, &quot;style&quot;: &quot;agnoster_full&quot; &#125; &#125; ], &quot;newline&quot;: true &#125; ], &quot;transient_prompt&quot;: &#123; &quot;foreground&quot;: &quot;#FEF5ED&quot;, &quot;background&quot;: &quot;transparent&quot;, &quot;template&quot;: &quot; &quot; &#125;&#125;","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://tonyjiangwj.github.io/tags/Shell/"}]},{"title":"相对安全方式保存SSH密码并实现自动登录","slug":"相对安全方式保存SSH密码并实现自动登录","date":"2021-03-18T12:34:52.000Z","updated":"2023-09-09T02:37:32.416Z","comments":true,"path":"2021/03/18/相对安全方式保存SSH密码并实现自动登录/","link":"","permalink":"https://tonyjiangwj.github.io/2021/03/18/%E7%9B%B8%E5%AF%B9%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F%E4%BF%9D%E5%AD%98SSH%E5%AF%86%E7%A0%81%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/","excerpt":"","text":"背景Linux或者Mac上一般都是直接用的终端来连接SSH，基本上很少有类似Windows上用XShell之类的客户端。所以在终端上直接登录都必须输入密码，但是如果密码比较复杂就更难记住了。这时候可以通过SSH-Key来实现秘钥登录。 SSH-Key登录远程服务器 SSH-Key是一种基于密钥的安全认证，远程服务器持有公钥，本地持有私钥，在客户端向服务器发送请求之后，服务端在用户主目录下查找用户的公钥，然后对比用户发送过来的公钥，如果一致则用公钥加密”质询“并发送给客户端。客户端收到”质询“后用私钥解密，在发送给服务端，认证结束。 要实现这种方式的登录首先需要创建ssh-key： ssh-keygen -t rsa 12345678- 在交互界面中可以按默认的直接回车，最后会在`$&#123;USER_HOME&#125;/.ssh/`下保存公钥和私钥文件：`id_rsa` `id_rsa.pub`- 然后需要将公钥保存到服务器上，执行以下命令即可将公钥发送到服务器上，需要输入登录密码- ```shell ssh-copy-id -i ~/.ssh/id_rsa.pub $&#123;user&#125;@$&#123;host&#125; 以上命令会将公钥文件保存到服务器用户目录下的 .ssh/authorized_keys 中 配置完成之后便可以直接免密码登录了 ssh $&#123;user&#125;@$&#123;host&#125; 其他扩展配置 有时候可能会需要创建多个不同的秘钥对，用于不同的服务器登陆，或者用于Github的免密操作 通过ssh-keygen创建新的文件，此时直接定义新的名字，比如： ssh-keygen -t rsa -C &#39;另一个服务器&#39; -f ~/.ssh/my_id_rsa 12345- 然后同样的将公钥发送到需要登录的服务器- ```shell ssh-copy-id -i ~/.ssh/my_id_rsa $&#123;user&#125;@$&#123;host&#125; 再在登录的时候指定私钥文件，或者通过 ~/.ssh/config 自动带上指定的文件 直接指定的方式： ssh $&#123;user&#125;@$&#123;host&#125; -i ~/.ssh/my_id_rsa 通过配置文件的方式： 1234567# ~/.ssh/config# 指定某一服务器所使用的私钥文件Host serverAlias # 服务器的别名，可以随便起一个 或者直接按ip也可以HostName $&#123;服务器的ip&#125;User $&#123;user&#125; # 指定登录用户名PreferredAuthentications publickeyIdentityFile ~/.ssh/my_id_rsa # 指定私钥文件 另一种情况 但是也有些情况下，无法将本地的公钥发送到服务器上，比如登录客户的服务器，或者登录一个IP或者端口可能会变化的服务器，比如我使用了免费的内网穿透来连接我的树莓派，它的端口就会经常变化。 在这种情况下，登录的时候都得去手动输入密码了。当用户名或者密码很难记住的时候，往往会特别需要一个能够记住用户名密码的客户端。Mac下免费的客户端较少，比如Termius就是一个不错的客户端，但是不知为何它有时候会卡死。所以我选择了自己实现记住密码的方式，可以在登录时只记住一个密码，将不同服务器的密码通过加密保存，登录的时候通过输入解密秘钥来自动解密登录。 通过加密文件保存服务器密码实现自动登录 通过该方式需要依赖的工具如下：openssl expect, 一般情况下 openssl都是自带了的，往往只需要安装一下expect Mac下可以直接 brew install expect Ubuntu 下可以通过apt安装 sudo apt install expect expect 是一种交互式的开源工具，用于实现自动化的功能 第一步创建加密方法，保存密码的密文 创建一个func.sh文件，内容如下 #!/bin/bash ## 加密方法 encrypt() &#123; local content=$1 local pass=$2 cmd=&quot;echo $content | openssl enc -aes-256-cfb -a -e -pass pass:$pass -iter 12 -nosalt&quot; echo $content | openssl enc -aes-256-cfb -a -e -pass pass:$pass -iter 12 -nosalt &#125; ## 加密工具方法 create_encrypted_pass() &#123; read -s -p &quot;Enter origin password:&quot; content echo &#39;&#39; read -s -p &quot;Enter aes password:&quot; pass echo &#39;&#39; encrypt $content $pass &#125; 123456789101112131415161718192021222324252627282930313233- 然后在终端中 `source func.sh` 加载方法，然后调用 `create_encrypted_pass` 在交互界面中输入密码和加密秘钥，加密秘钥需要牢记于心，以后登录时只需要输入它即可- 完成后会打印加密后的密文，将密文保存下来，比如保存到`$&#123;host&#125;.pass` #### 第二步创建解密方法，和自动登录的方法- 在func.sh中补充解密和登录方法- ```shell ## 解密方法 decrypt() &#123; local encrypted=$1 local pass=$2 echo $encrypted | openssl enc -aes-256-cfb -a -d -pass pass:$pass -iter 12 -nosalt &#125; ## 登录方法，输入参数有 加密文件路径，用户名，服务器host，（端口，解密秘钥【这两个可选】） ssh_target() &#123; local pass_path=$1 local user=$2 local host=$3 local port=$4 local aes_pass=$5 if [ &quot;$port&quot; == &quot;&quot; ]; then port=22 fi encrypted=`cat $pass_path` pass=`decrypt $encrypted $aes_pass` # echo &quot;decrypted pass is $&#123;pass&#125;&quot; ./_ssh.exp $host $user $pass $port &#125; 然后创建自动执行脚本，_ssh.exp，用于根据输入参数自动登录到服务器上 #!/usr/bin/expect ## 读取参数 set host [lindex $argv 0] set user [lindex $argv 1] set password [lindex $argv 2] set port [lindex $argv 3] set timeout 3000 spawn ssh -l $user $host -p $port expect &#123; # 判断是否有记住hosts的交互信息 &quot;(yes/no?&quot; &#123; send &quot;yes\\r&quot; # 发送yes expect &#123; &quot;password:&quot; &#123; send &quot;$&#123;password&#125;\\r&quot; &#125; # 发送密码 &#125; &#125; &quot;password:&quot; &#123; send &quot;$&#123;password&#125;\\r&quot; &#125; # 发送密码 &#125; interact 12345678- 然后只需要在创建一个针对某一服务器的登录脚本，在里面配置一些信息- 比如 ssh_my_server.sh- ```shell source ./func.sh ## 用于加载预定义的方法 ssh_target $&#123;hist&#125;.pass $&#123;用户名&#125; $&#123;服务器host&#125; $&#123;端口&#125; 然后对以上两个文件赋予可执行权限 chmod a+x ssh_my_server.sh _ssh.exp 第三步，登录服务器 此时要登录到服务器时，只需要执行 ssh_my_server.sh 即可 ./ssh_my_server.sh 然后根据提示输入加密秘钥，这个秘钥牢记于心即可。一般不知道秘钥无法解密出具体的登录密码，所以是比较安全的，在脚本中也不会暴露密码信息。 额外实现 以上方式，每次执行 ./ssh_my_server.sh 都需要输入一遍密码，有时候又觉得有些麻烦。可以稍微再改造一下，在当前终端中不再需要输入密码。实现方式是得到和终端相关的数据，用它作为加密密钥，将记在心里的那个秘钥保存下来。 在func.sh中增加有些方法，并修改ssh_target ## 根据终端的信息创建临时秘钥，该方法创建的秘钥只要在当前终端执行，得到的都是同样的内容 create_temp_pass() &#123; local tty_info=`tty` tty_info=$&#123;tty_info#/dev/*&#125; local ps_info=`ps -ef | grep $tty_info | awk &#39;NR==1&#123;print $2,$3,$5,$6&#125;&#39;` local aes_pass=`echo $ps_info | md5` echo $aes_pass &#125; ## 从加密文件中解密出明文密码 get_session_aes_pass() &#123; local work_dir=`pwd` local temp_pass_dir=&quot;$work_dir/.pass&quot; local aes_pass=&#39;&#39; # 判断是否存在加密文件，不存在则返回空内容 if test -e $temp_pass_dir ; then local encrypted_aes_pass=`cat $temp_pass_dir` local temp_aes_pass=`create_temp_pass` # 判断密文解密的合法性，我在明文中加入了_123后缀，只有后缀匹配才能确定解密是成功的，否则解密失败返回空内容 local decrypted_aes_pass=`decrypt $encrypted_aes_pass $temp_aes_pass` if [ &quot;$&#123;decrypted_aes_pass#*_&#125;&quot; == &quot;123&quot; ]; then aes_pass=$&#123;decrypted_aes_pass%_123&#125; fi fi echo $aes_pass &#125; ## 将明文密码保存到加密文件中 save_session_aes_pass() &#123; local work_dir=`pwd` local temp_pass_dir=&quot;$work_dir/.pass&quot; local aes_pass=$1 local temp_aes_pass=`create_temp_pass` # 在明文中加入_123后缀，然后加密到加密文件中 local encrypted_aes_pass=`encrypt &quot;$&#123;aes_pass&#125;_123&quot; $temp_aes_pass` echo $encrypted_aes_pass &gt; $temp_pass_dir &#125; ssh_target() &#123; local pass_path=$1 local user=$2 local host=$3 local port=$4 local aes_pass=$5 if [ &quot;$port&quot; == &quot;&quot; ]; then port=22 fi encrypted=`cat $pass_path` # 这里增加判断，如果传入的解密密码为空， if [ &quot;$aes_pass&quot; == &quot;&quot; ]; then aes_pass=`get_session_aes_pass` # 第二次判断，如果解密出的内容为空，则需要重新输入解密的秘钥 if [ &quot;$aes_pass&quot; == &quot;&quot; ]; then read -s -p &#39;please enter aes password:&#39; aes_pass echo &#39;&#39; # 将秘钥明文加密保存 `save_session_aes_pass $aes_pass` fi fi pass=`decrypt $encrypted $aes_pass` # echo &quot;decrypted pass is $&#123;pass&#125;&quot; ../libs/_ssh.exp $host $user $pass $port &#125; 然后在同一个终端中，只在第一次执行 ssh_my_server.sh 的时候需要输入密码，在后续的操作中不再需要输入密码。当重新打开一个终端时，才会要求再次输入密码。 当需要登录多个不同的服务器时，可以创建多个不同的ssh_my_server.sh文件，顺序分别是先创建登录密码的加密文件，然后在ssh_my_server.sh文件中配置加密文件位置和服务器登录名，host，端口等信息。","categories":[],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://tonyjiangwj.github.io/tags/Shell/"}]},{"title":"将opencv-android-sdk打包成aar文件","slug":"将opencv-android-sdk打包成aar文件","date":"2021-01-07T02:11:34.000Z","updated":"2023-09-09T07:34:08.594Z","comments":true,"path":"2021/01/07/将opencv-android-sdk打包成aar文件/","link":"","permalink":"https://tonyjiangwj.github.io/2021/01/07/%E5%B0%86opencv-android-sdk%E6%89%93%E5%8C%85%E6%88%90aar%E6%96%87%E4%BB%B6/","excerpt":"","text":"本文介绍的是如何将opencv-android-sdk打包成aar文件，以便作为lib包导入到现有项目中第一步、下载opencv-android-sdk 前往opencv官网https://opencv.org/releases/ 下载对应版本的Android-sdk.zip，然后解压备用。 这里不管是4.x还是3.x都可以，后续步骤是一样的 第二步、创建一个空的项目 打开Android Studio，create new project 随便选一个Empty Activity然后第二页随便写名称，minimun sdk选择21以上即可 创建完毕之后，通过菜单new module, 选择Android Library 填写Android Library信息，同样选择Mininum SDK为21以上，其他的可以随便写，我这里包名写成org.opencv 右键opencv模块，创建AIDL文件夹 第三步、复制SDK源代码到项目中 为了方便查看目录结构，切换为Project 将 [opencv-sdk-dir]/sdk/java/src/org/opencv/engine/OpenCVEngineInterface.aidl 文件复制到 [opencv-module]/src/main/aidl/org/opencv/engine/OpenCVEngineInterface.aidl 将 [opencv-sdk-dir]/sdk/java/src/ 下的文件夹复制到 [opencv-module]/src/main/java 将 [opencv-sdk-dir]/sdk/native/libs/ 下的arm64-v8a armeabi-v7 文件夹复制到 [opencv-module]/src/main/jniLibs 。作为aar打包，这一步是可选的，因为加入后会增加打包体积，可以后续直接在引用项目中再添加对应的so文件 将 [opencv-sdk-dir]/sdk/java/res/values/attrs.xml 文件复制到 [opencv-module]/src/main/res/values/attrs.xml 完成后的目录如下 然后修改[opencv-module]&#x2F;build.gradle 增加lintOptions 避免lint报错打断打包进程 第四步、打包aar文件 运行 gradle task build，双击build即可 打包完成后aar文件在 [opencv-module]/build/outputs/aar/ 目录下，本教程直接跳过了jniLibs，打包体积在几百kB左右 如果需要将jniLibs一起打包，可能需要在build.gradle中配置ndk.version为本地已安装的版本 否则可能报错 这样打包后的aar文件大概有十几MB","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://tonyjiangwj.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://tonyjiangwj.github.io/tags/Android/"}]},{"title":"自建kms服务器并通过docker部署","slug":"自建kms服务器并通过docker部署","date":"2020-07-21T12:08:39.000Z","updated":"2023-09-09T02:37:32.417Z","comments":true,"path":"2020/07/21/自建kms服务器并通过docker部署/","link":"","permalink":"https://tonyjiangwj.github.io/2020/07/21/%E8%87%AA%E5%BB%BAkms%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E9%80%9A%E8%BF%87docker%E9%83%A8%E7%BD%B2/","excerpt":"","text":"通过docker创建自己的kms服务容器，并部署到Linux服务器或者树莓派上 本教程实现了基于docker创建自己的 kms 容器，并实现开机自启动的功能 kms脚本来自https://github.com/dakkidaze/one-key-kms.git 首先进入home创建文件夹 mkdir ~/kms-tmp &amp;&amp; cd ~/kms-tmp 下载kms脚本 git clone https://github.com/dakkidaze/one-key-kms.git 创建临时容器 vim Dockerfile12345678FROM arm32v7/ubuntu:18.04COPY one-key-kms /home/root/one-key-kmsWORKDIR /home/root/one-key-kmsRUN apt update &amp;&amp; apt install vim -y &amp;&amp; apt install curl -yRUN chmod a+x *.shRUN echo &quot;done kms!&quot; 创建镜像 docker build . -t kms-tmp:v1 运行创建的容器 docker run -it kms-tmp:v1 执行 ./one-key-kms-debian.sh 进行安装，自动下载依赖的组件 完成后手动退出容器，将容器创建为镜像 docker commit $container_id kms/kms-tmp 开始创建kms镜像 mkdir ~/kms &amp;&amp; cd ~/kms vim start_kms.sh #!/bin/bash /home/root/one-key-kms/kms.sh start ## 阻塞主程序 防止docker容器启动后退出 watch -n 100 -d &#39;df -h&#39; 1234567- ` vim Dockerfile ` 编写Dockerfile 需要暴露 1688 端口 ```shell FROM kms/kms-tmp:latest WORKDIR /home/root/one-key-kms COPY start_kms.sh /home/root/one-key-kms RUN chmod a+x start_kms.sh EXPOSE 1688 容器创建完成之后运行即可 docker run -dit -p 1688:1688 \\ --name kms \\ --entrypoint &quot;/home/root/one-key-kms/start_kms.sh&quot; \\ --restart=always kms:v1 --restart=always 是指定容器自动启动 windows下激活脚本 进入system32目录下 cd %SystemRoot%/system32 设置服务器ip slmgr /skms kms服务器ip 激活产品 slmgr /ato 查看激活信息 slmgr /xpr office激活进入安装目录 设置激活服务器 cscript ospp.vbs /sethst:$kmsip 激活产品 cscript ospp.vbs /act","categories":[],"tags":[]},{"title":"使用Protobuf实现跨语言序列化和反序列化，Java&Python实例","slug":"使用Protobuf实现跨语言序列化和反序列化，Java-Python实例","date":"2019-11-01T05:46:27.000Z","updated":"2023-09-09T02:37:32.401Z","comments":true,"path":"2019/11/01/使用Protobuf实现跨语言序列化和反序列化，Java-Python实例/","link":"","permalink":"https://tonyjiangwj.github.io/2019/11/01/%E4%BD%BF%E7%94%A8Protobuf%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%AF%AD%E8%A8%80%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8CJava-Python%E5%AE%9E%E4%BE%8B/","excerpt":"","text":"使用protobuf实现跨语言序列化 Java和Python实例首先下载安装protoc github.releases 对于OS X可以通过brew直接安装 brew install protobuf 安装完可以通过protoc --version查看版本信息 创建proto文件-带Any类型的版本带Any类型的只能导出pb2类型的Python文件，没法导出Python3 的版本，暂时不知道如何解决 Any类型的字段可以在java中实现泛型的功能 MessageDto.proto 1234567syntax = &quot;proto3&quot;;import &quot;google/protobuf/any.proto&quot;;message MessageDto &#123; string action=1; int32 statte=2; google.protobuf.Any data=3;&#125; RpcCmd.proto 1234567syntax = &quot;proto3&quot;;import &quot;MessageDto.proto&quot;;message RpcCmd &#123; MessageDto message=1; string randomKey=2; string remoteAddressKey=3;&#125; Point2PointMessage.proto 12345syntax = &quot;proto3&quot;;message Point2PointMessage &#123; string targetAddressKey; string message;&#125; BytesData.proto 1234syntax = &quot;proto3&quot;;message BytesData &#123; bytes content=1;&#125; 导出相应的对象定义文件Python版 protoc --python_out=./gen_pb2 RpcCmd.proto MessageDto.proto Point2PointMessage.proto BytesData.proto 生成的文件名为XXX_pb2.py Java版 protoc --java_out=./gen_java RpcCmd.proto MessageDto.proto Point2PointMessage.proto BytesData.proto 生成的文件名为XXXOuterClass.java 在Python中使用 首先要导入生成的文件，放到自己喜欢的包下，然后修改导入包的地址，比如RpcCmd_pb2.py中修改 1import com.tony.proto.py2.MessageDto_pb2 as MessageDto__pb2 然后开始使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from com.tony.proto.py2 import RpcCmd_pb2, Point2PointMessage_pb2, BytesData_pb2, MessageDto_pb2def serialize_to_file(file_path): p2p_msg = Point2PointMessage_pb2.Point2PointMessage() p2p_msg.message = &quot;Hello, p2p from python&quot; p2p_msg.targetAddressKey = &quot;/127.0.0.1:38211&quot; # bytes_data = BytesData_pb2.BytesData() # bytes_data.content = b&quot;Hello, bytes data from python&quot; rpc_cmd = RpcCmd_pb2.RpcCmd() rpc_cmd.randomKey = &quot;random-key-key-random&quot; rpc_cmd.remoteAddressKey = &quot;/127.0.0.1:1234&quot; rpc_cmd.message.action = &quot;p2p&quot; rpc_cmd.message.state = 100 rpc_cmd.message.data.Pack(p2p_msg) # rpc_cmd.message.data.Pack(bytes_data) bytes_write = rpc_cmd.SerializeToString() fw = open(file_path, mode=&quot;wb&quot;) fw.write(bytes_write) fw.flush() fw.close() print(&quot;write bytes to file:&quot;, bytes_write)def deserialize_from_file(file_path): fo = open(file_path, mode=&quot;rb&quot;) bytes_read = fo.read() fo.close() print(&quot;read bytes from file:&quot;, bytes_read) rpc_cmd = RpcCmd_pb2.RpcCmd() rpc_cmd.ParseFromString(bytes_read) print(rpc_cmd) p2p_msg = Point2PointMessage_pb2.Point2PointMessage() # bytes_data = BytesData_pb2.BytesData() # rpc_cmd.message.data.Unpack(bytes_data) rpc_cmd.message.data.Unpack(p2p_msg) print(&quot;msg_content:&quot;, p2p_msg.message) print(&quot;msg_target:&quot;, p2p_msg.targetAddressKey) # print(&quot;bytes_data:&quot;, str(bytes_data.content, &#x27;utf-8&#x27;))if __name__ == &quot;__main__&quot;: serialize_file_path = &quot;/trans-data-pb2.dat&quot; serialize_to_file(serialize_file_path) deserialize_from_file(serialize_file_path) 执行结果如下，可以将bytes_data相关的注释取消同时注释掉p2p_msg相关的测试BytesData类型的序列化和反序列化 123456789101112131415write bytes to file: b&#x27;\\n]\\n\\x03p2p\\x10d\\x1aT\\n&amp;type.googleapis.com/Point2PointMessage\\x12*\\n\\x10/127.0.0.1:38211\\x12\\x16Hello, p2p from python\\x12\\x15random-key-key-random\\x1a\\x0f/127.0.0.1:1234&#x27;read bytes from file: b&#x27;\\n]\\n\\x03p2p\\x10d\\x1aT\\n&amp;type.googleapis.com/Point2PointMessage\\x12*\\n\\x10/127.0.0.1:38211\\x12\\x16Hello, p2p from python\\x12\\x15random-key-key-random\\x1a\\x0f/127.0.0.1:1234&#x27;message &#123; action: &quot;p2p&quot; state: 100 data &#123; type_url: &quot;type.googleapis.com/Point2PointMessage&quot; value: &quot;\\n\\020/127.0.0.1:38211\\022\\026Hello, p2p from python&quot; &#125;&#125;randomKey: &quot;random-key-key-random&quot;remoteAddressKey: &quot;/127.0.0.1:1234&quot;msg_content: Hello, p2p from pythonmsg_target: /127.0.0.1:38211 在Java中使用 同样导入到喜欢的包下，修改对应的包名即可 123456789101112131415161718192021222324252627282930313233343536373839@Slf4jpublic class ProtobufSerializeDemo &#123; @Test public void serializeToFile() throws Exception &#123; Point2PointMessageOuterClass.Point2PointMessage.Builder p2pMsgBuilder = Point2PointMessageOuterClass.Point2PointMessage.newBuilder(); p2pMsgBuilder.setTargetAddressKey(&quot;/127.0.0.1:1233&quot;); p2pMsgBuilder.setMessage(&quot;hello from java&quot;);// BytesDataOuterClass.BytesData.Builder bytesBuilder = BytesDataOuterClass.BytesData.newBuilder();// bytesBuilder.setContent(ByteString.copyFrom(&quot;bytes data from java&quot;.getBytes(StandardCharsets.UTF_8))); MessageDtoOuterClass.MessageDto.Builder messageBuilder = MessageDtoOuterClass.MessageDto.newBuilder(); messageBuilder.setAction(&quot;p2p&quot;); messageBuilder.setState(100); messageBuilder.setData(Any.pack(p2pMsgBuilder.build()));// messageBuilder.setData(Any.pack(bytesBuilder.build())); RpcCmdOuterClass.RpcCmd.Builder builder = RpcCmdOuterClass.RpcCmd.newBuilder(); builder.setRandomKey(&quot;RANDOM_KEY_JAVA&quot;); builder.setRemoteAddressKey(&quot;/127.0.0.1:1234&quot;); builder.setMessage(messageBuilder.build()); builder.build().writeTo(new FileOutputStream(&quot;java_protobuf.dat&quot;)); &#125; @Test public void deserializeFromFile() throws Exception &#123; RpcCmdOuterClass.RpcCmd rpcCmd = RpcCmdOuterClass.RpcCmd.parseFrom(new FileInputStream(&quot;java_protobuf.dat&quot;)); Point2PointMessageOuterClass.Point2PointMessage p2pMsg = rpcCmd.getMessage().getData().unpack(Point2PointMessageOuterClass.Point2PointMessage.class);// BytesDataOuterClass.BytesData bytesData = rpcCmd.getMessage().getData().unpack(BytesDataOuterClass.BytesData.class); log.info(&quot;deserialize rpcCmd: \\n&#123;&#125;&quot;, rpcCmd); log.info(&quot;deserialize p2pMsg: \\n&#123;&#125;&quot;, p2pMsg);// log.info(&quot;deserialize bytesData: \\n&#123;&#125;&quot;, bytesData); &#125;&#125; 执行结果，可以将bytes_data相关的注释取消同时注释掉p2p_msg相关的测试BytesData类型的序列化和反序列化 1234567891011121314151610:22:03.118 [main] INFO com.tony.proto.ProtobufSerializeDemo - deserialize rpcCmd: message &#123; action: &quot;p2p&quot; state: 100 data &#123; type_url: &quot;type.googleapis.com/Point2PointMessage&quot; value: &quot;\\n\\017/127.0.0.1:1233\\022\\017hello from java&quot; &#125;&#125;randomKey: &quot;RANDOM_KEY_JAVA&quot;remoteAddressKey: &quot;/127.0.0.1:1234&quot;10:22:03.168 [main] INFO com.tony.proto.ProtobufSerializeDemo - deserialize p2pMsg: targetAddressKey: &quot;/127.0.0.1:1233&quot;message: &quot;hello from java&quot; 然后是Java和Python之间互相序列化和反序列化 只需要修改对应的文件地址就可以进行测试 Python反序列化Java 12java_serialize_file_path = $path_to_java_serialized$deserialize_from_file(java_serialize_file_path) 执行结果，这里演示的是BytesData类型的 12345678910111213read bytes from file: b&#x27;\\n@\\n\\x03p2p\\x10d\\x1a7\\n\\x1dtype.googleapis.com/BytesData\\x12\\x16\\n\\x14bytes data from java\\x12\\x0fRANDOM_KEY_JAVA\\x1a\\x0f/127.0.0.1:1234&#x27;message &#123; action: &quot;p2p&quot; state: 100 data &#123; type_url: &quot;type.googleapis.com/BytesData&quot; value: &quot;\\n\\024bytes data from java&quot; &#125;&#125;randomKey: &quot;RANDOM_KEY_JAVA&quot;remoteAddressKey: &quot;/127.0.0.1:1234&quot;bytes_data: bytes data from java Java反序列化Python 123456789 @Test public void deserializeFromPythonFile() throws Exception &#123; RpcCmdOuterClass.RpcCmd rpcCmd = RpcCmdOuterClass.RpcCmd.parseFrom(new FileInputStream($path_to_python_serialize$));// Point2PointMessageOuterClass.Point2PointMessage p2pMsg = rpcCmd.getMessage().getData().unpack(Point2PointMessageOuterClass.Point2PointMessage.class); BytesDataOuterClass.BytesData bytesData = rpcCmd.getMessage().getData().unpack(BytesDataOuterClass.BytesData.class); log.info(&quot;deserialize rpcCmd: \\n&#123;&#125;&quot;, rpcCmd);// log.info(&quot;deserialize p2pMsg: \\n&#123;&#125;&quot;, p2pMsg); log.info(&quot;deserialize bytesData: \\n&#123;&#125;&quot;, bytesData); &#125; 执行结果，同样是BytesData类型的 12345678910111213141510:33:03.360 [main] INFO com.tony.proto.ProtobufSerializeDemo - deserialize rpcCmd: message &#123; action: &quot;p2p&quot; state: 100 data &#123; type_url: &quot;type.googleapis.com/BytesData&quot; value: &quot;\\n\\035Hello, bytes data from python&quot; &#125;&#125;randomKey: &quot;random-key-key-random&quot;remoteAddressKey: &quot;/127.0.0.1:1234&quot;10:33:03.402 [main] INFO com.tony.proto.ProtobufSerializeDemo - deserialize bytesData: content: &quot;Hello, bytes data from python&quot; 在Java平台，还有个更好用的工具可以不用手写proto文件 这个工具是io.protostuff 通过maven导入依赖 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;io.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 用于创建对象 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.objenesis&lt;/groupId&gt; &lt;artifactId&gt;objenesis&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt; 创建序列化工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import io.protostuff.LinkedBuffer;import io.protostuff.ProtobufIOUtil;import io.protostuff.Schema;import io.protostuff.runtime.DefaultIdStrategy;import io.protostuff.runtime.RuntimeSchema;import lombok.extern.slf4j.Slf4j;import org.objenesis.Objenesis;import org.objenesis.ObjenesisStd;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;/** * 基于Protostuff优化版的ProtobufIOUtil实现序列化，理论上可以支持跨语言序列化 * * @author jiangwenjie 2019/10/30 */@Slf4jpublic class ProtobufSerializer &#123; private final static Objenesis OBJENESIS = new ObjenesisStd(true); private ProtobufSerializer() &#123; &#125; private static class SingletonHolder &#123; final static ProtobufSerializer INSTANCE = new ProtobufSerializer(); &#125; public static ProtobufSerializer getInstance() &#123; return ProtobufSerializer.SingletonHolder.INSTANCE; &#125; public void serialize(Object obj, OutputStream outputStream) &#123; Class clz = obj.getClass(); LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE); try &#123; Schema schema = getSchema(clz); ProtobufIOUtil.writeTo(outputStream, obj, schema, buffer); &#125; catch (IOException e) &#123; log.error(&quot;序列化对象失败&quot;, e); &#125; finally &#123; buffer.clear(); &#125; &#125; public byte[] serialize(Object obj) &#123; Class clz = obj.getClass(); LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE); try (ByteArrayOutputStream arrayOutputStream = new ByteArrayOutputStream()) &#123; Schema schema = getSchema(clz); ProtobufIOUtil.writeTo(arrayOutputStream, obj, schema, buffer); return arrayOutputStream.toByteArray(); &#125; catch (IOException e) &#123; log.error(&quot;序列化对象失败&quot;, e); &#125; finally &#123; buffer.clear(); &#125; return new byte[0]; &#125; public &lt;T&gt; T deSerialize(InputStream inputStream, Class&lt;T&gt; clazz) &#123; T object = OBJENESIS.newInstance(clazz); Schema&lt;T&gt; schema = getSchema(clazz); try &#123; ProtobufIOUtil.mergeFrom(inputStream, object, schema); return object; &#125; catch (IOException e) &#123; log.error(&quot;反序列化对象失败&quot;, e); &#125; return null; &#125; public &lt;T&gt; T deSerialize(byte[] param, Class&lt;T&gt; clazz) &#123; T object = OBJENESIS.newInstance(clazz); Schema&lt;T&gt; schema = getSchema(clazz); try (ByteArrayInputStream inputStream = new ByteArrayInputStream(param)) &#123; ProtobufIOUtil.mergeFrom(inputStream, object, schema); return object; &#125; catch (IOException e) &#123; log.error(&quot;反序列化对象失败&quot;, e); &#125; return null; &#125; private &lt;T&gt; Schema&lt;T&gt; getSchema(Class&lt;T&gt; clz) &#123; return RuntimeSchema.createFrom(clz, new DefaultIdStrategy()); &#125;&#125; 创建序列化对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.io.Serializable;/** * @author jiangwenjie 2019/10/22 */@Data@Slf4jpublic class RpcCmd implements Serializable &#123; private MessageDto message; private String randomKey; /** * 目标地址，不需要序列化传输 */ private transient String remoteAddressKey;&#125;import com.tony.constants.EnumNettyState;import com.tony.serializer.impl.ProtobufSerializer;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.ToString;import lombok.extern.slf4j.Slf4j;import java.io.Serializable;/** * 消息对象 * * @author jiangwenjie 2019/10/22 */@Slf4j@Data@ToString@EqualsAndHashCodepublic class MessageDto implements Serializable &#123; private String action; private int state = 100; /** * 跨语言使用Protostuff中提供的protobuff序列化传递复杂对象 */ private byte[] bytesData; private Serializable serialData; public &lt;T&gt; T dataOfClazz(Class&lt;T&gt; clazz, boolean isStuff) &#123; if (isStuff) &#123; return serialDataOfClazz(clazz); &#125; else &#123; return bytesDataOfClass(clazz); &#125; &#125; public &lt;T extends Serializable&gt; void setData(T object, boolean isStuff) &#123; if (isStuff) &#123; setSerialData(object); &#125; else &#123; setBytesData(object); &#125; &#125; @SuppressWarnings(&quot;unchecked&quot;) private &lt;T&gt; T serialDataOfClazz(Class&lt;T&gt; clazz) &#123; if (serialData == null) &#123; return null; &#125; if (clazz.isInstance(serialData)) &#123; return (T)serialData; &#125; else &#123; throw new IllegalArgumentException(&quot;data is not instance of class:&quot; + clazz.getName()); &#125; &#125; private &lt;T&gt; T bytesDataOfClass(Class&lt;T&gt; clazz) &#123; if (bytesData == null) &#123; return null; &#125; try &#123; return ProtobufSerializer.getInstance().deSerialize(bytesData, clazz); &#125; catch (Exception e) &#123; log.error(&quot;反序列化data对象失败，请确认对象是否为：&#123;&#125; 类型&quot;, clazz); &#125; return null; &#125; private &lt;T extends Serializable&gt; void setBytesData(T data) &#123; this.bytesData = ProtobufSerializer.getInstance().serialize(data); &#125;&#125;import lombok.Data;import java.io.Serializable;/** * 点对点通信data对象 * * @author jiangwenjie 2019/10/26 */@Datapublic class Point2PointMessage implements Serializable &#123; private String targetAddressKey; private String message;&#125; 序列化测试123456789101112131415161718192021222324252627282930313233343536import lombok.extern.slf4j.Slf4j;import org.junit.Test;import java.io.FileInputStream;import java.io.FileOutputStream;/** * @author jiangwenjie 2019/11/1 */@Slf4jpublic class JavaProtostuffSerializeDemo &#123; @Test public void serializeToFile() throws Exception &#123; Point2PointMessage p2pMsg = new Point2PointMessage(); p2pMsg.setTargetAddressKey(&quot;/127.0.0.1:1233&quot;); p2pMsg.setMessage(&quot;message from java&quot;); MessageDto messageDto = new MessageDto(); messageDto.setAction(&quot;p2p&quot;); messageDto.setState(100); messageDto.setData(p2pMsg, false); RpcCmd rpcCmd = new RpcCmd(); rpcCmd.setMessage(messageDto); rpcCmd.setRandomKey(&quot;RANDOM_KEY_JAVA&quot;); rpcCmd.setRemoteAddressKey(&quot;/127.0.0.1:1234&quot;); ProtobufSerializer.getInstance().serialize(rpcCmd, new FileOutputStream(&quot;java_proto_simple.dat&quot;)); &#125; @Test public void deserializeFromFile() throws Exception &#123; RpcCmd rpcCmd = ProtobufSerializer.getInstance().deSerialize(new FileInputStream(&quot;java_proto_simple.dat&quot;), RpcCmd.class); log.info(&quot;deserialize cmd:\\n&#123;&#125;&quot;, rpcCmd); log.info(&quot;deserialize p2p msg:\\n&#123;&#125;&quot;, rpcCmd.getMessage().dataOfClazz(Point2PointMessage.class, false)); &#125;&#125; 测试输出123411:02:45.646 [main] INFO com.tony.simple.JavaProtostuffSerializeDemo - deserialize cmd:RpcCmd(message=MessageDto(action=p2p, state=100, bytesData=[10, 15, 47, 49, 50, 55, 46, 48, 46, 48, 46, 49, 58, 49, 50, 51, 51, 18, 17, 109, 101, 115, 115, 97, 103, 101, 32, 102, 114, 111, 109, 32, 106, 97, 118, 97], serialData=null, isFromBuff=false), randomKey=RANDOM_KEY_JAVA, remoteAddressKey=null)11:02:45.651 [main] INFO com.tony.simple.JavaProtostuffSerializeDemo - deserialize p2p msg:Point2PointMessage(targetAddressKey=/127.0.0.1:1233, message=message from java) MessageDto中的Data 可以泛型化使用12345/** * 跨语言使用Protostuff中提供的protobuff序列化传递复杂对象 */private byte[] bytesData;private Serializable serialData; 当序列化和反序列化不需要跨平台使用时，可以直接使用Serializable类型，反之需要用byte数组保存数据，进行二次序列化和反序列化。同时可以在序列化工具类ProtobufSerializer中将ProtobufIOUtil修改为ProtostuffIOUtil 通过setData方法进行响应的操作 1234567public &lt;T extends Serializable&gt; void setData(T object, boolean isStuff) &#123; if (isStuff) &#123; setSerialData(object); &#125; else &#123; setBytesData(object); &#125;&#125; 跨语言Python中反序列化创建proto文件 MessageDto.proto 1234567syntax = &quot;proto3&quot;;message MessageDto &#123; string action=1; int32 state=2; bytes data=3;&#125; RpcCmd.proto 12345678syntax = &quot;proto3&quot;;import &quot;MessageDto.proto&quot;;message RpcCmd &#123; MessageDto message = 1; string randomKey = 2; string remoteAddressKey = 3;&#125; Point2PointMessage.proto 1234567syntax = &quot;proto3&quot;;message Point2PointMessage &#123; bytes java_class = 127; string targetAddressKey = 1; string message = 2;&#125; BytesData.proto 1234syntax = &quot;proto3&quot;;message BytesData &#123; bytes content=1;&#125; 导出Python3对象定义文件 此时没有用到Any类型 可以直接导出为Python3的py文件 protoc --python3_out=./gen RpcCmd.proto MessageDto.proto Point2PointMessage.proto BytesData.proto 和pb2的区别是序列化和反序列化的方法名称进行了修改 pb2中用的是ParseFromString和SerializeToString pb3中修改成了encode_to_bytes和parse_from_bytes 在Python中使用 同样的放到喜欢的包下，修改对应包名 这里不赘述 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/python3# -*-coding: utf-8 -*-from com.tony.proto.py3 import RpcCmd, Point2PointMessage, MessageDto, BytesDatadef serialize_to_file(file_path): p2p_msg = Point2PointMessage.Point2PointMessage() p2p_msg.message = &quot;Hello, p2p from python&quot; p2p_msg.targetAddressKey = &quot;/127.0.0.1:38211&quot; # bytes_data = BytesData.BytesData() # bytes_data.content = &quot;bytes data from python&quot; rpc_cmd = RpcCmd.RpcCmd() rpc_cmd.randomKey = &quot;random-key-key-random&quot; rpc_cmd.remoteAddressKey = &quot;/127.0.0.1:1234&quot; rpc_cmd.message.action = &quot;p2p&quot; rpc_cmd.message.state = 100 rpc_cmd.message.data = p2p_msg.encode_to_bytes() # rpc_cmd.message.data = bytes_data.encode_to_bytes() bytes_write = rpc_cmd.encode_to_bytes() fw = open(file_path, mode=&quot;wb&quot;) fw.write(bytes_write) fw.flush() fw.close() print(&quot;write bytes to file:&quot;, bytes_write)def deserialize_from_file(file_path): fo = open(file_path, mode=&quot;rb&quot;) bytes_read = fo.read() fo.close() print(&quot;read bytes from file:&quot;, bytes_read) rpc_cmd = RpcCmd.RpcCmd() rpc_cmd.parse_from_bytes(bytes_read) print(rpc_cmd) msg_bytes = rpc_cmd.message.data print(&quot;message bytes&quot;, msg_bytes) p2p_msg = data_of(rpc_cmd.message, Point2PointMessage.Point2PointMessage) # bytes_data = data_of(rpc_cmd.message, BytesData.BytesData) print(&quot;msg_content:&quot;, p2p_msg.message) print(&quot;msg_target:&quot;, p2p_msg.targetAddressKey) # print(&quot;bytes_data:&quot;, bytes_data.content)def data_of(message: RpcCmd.MessageDto, message_identify): content = message_identify() content.parse_from_bytes(message.data) return contentif __name__ == &quot;__main__&quot;: serialize_file_path = &quot;./trans-data.dat&quot; serialize_to_file(serialize_file_path) deserialize_from_file(serialize_file_path) 执行结果如下，同样的可以将bytes_data相关的注释取消同时注释掉p2p_msg相关的测试BytesData类型的序列化和反序列化 123456789101112write bytes to file: b&#x27;\\n3\\n\\x03p2p\\x10d\\x1a*\\n\\x10/127.0.0.1:38211\\x12\\x16Hello, p2p from python\\x12\\x15random-key-key-random\\x1a\\x0f/127.0.0.1:1234&#x27;read bytes from file: b&#x27;\\n3\\n\\x03p2p\\x10d\\x1a*\\n\\x10/127.0.0.1:38211\\x12\\x16Hello, p2p from python\\x12\\x15random-key-key-random\\x1a\\x0f/127.0.0.1:1234&#x27;&lt;Message(RpcCmd)&gt; &lt;MessageField(id=1, optional)&gt;: &lt;Message(MessageDto)&gt; &lt;StringField(id=1, optional)&gt;: p2p &lt;Int32Field(id=2, optional)&gt;: 100 &lt;BytesField(id=3, optional)&gt;: b&#x27;\\n\\x10/127.0.0.1:38211\\x12\\x16Hello, p2p from python&#x27; &lt;StringField(id=2, optional)&gt;: random-key-key-random &lt;StringField(id=3, optional)&gt;: /127.0.0.1:1234message bytes b&#x27;\\n\\x10/127.0.0.1:38211\\x12\\x16Hello, p2p from python&#x27;msg_content: Hello, p2p from pythonmsg_target: /127.0.0.1:38211 Python和Java互转 同样是仅仅修改序列化文件地址即可 Python反序列化Java java_serialize_file_path = $path_to_java_serialized$ deserialize_from_file(java_serialize_file_path) 123- 执行结果 read bytes from file: b&#39;\\n-\\n\\x03p2p\\x10d\\x1a$\\n\\x0f/127.0.0.1:1233\\x12\\x11message from java\\x12\\x0fRANDOM_KEY_JAVA&#39; &lt;Message(RpcCmd)&gt; &lt;MessageField(id=1, optional)&gt;: &lt;Message(MessageDto)&gt; &lt;StringField(id=1, optional)&gt;: p2p &lt;Int32Field(id=2, optional)&gt;: 100 &lt;BytesField(id=3, optional)&gt;: b&#39;\\n\\x0f/127.0.0.1:1233\\x12\\x11message from java&#39; &lt;StringField(id=2, optional)&gt;: RANDOM_KEY_JAVA message bytes b&#39;\\n\\x0f/127.0.0.1:1233\\x12\\x11message from java&#39; msg_content: message from java msg_target: /127.0.0.1:1233 1234567891011###### Java反序列化Python- ```java @Test public void deserializeFromPythonFile() throws Exception &#123; RpcCmd rpcCmd = ProtobufSerializer.getInstance() .deSerialize(new FileInputStream($python_serialize_path$), RpcCmd.class); log.info(&quot;deserialize cmd:\\n&#123;&#125;&quot;, rpcCmd); log.info(&quot;deserialize p2p msg:\\n&#123;&#125;&quot;, rpcCmd.getMessage().dataOfClazz(Point2PointMessage.class, false)); &#125; 执行结果 123413:15:17.821 [main] INFO com.tony.simple.JavaProtostuffSerializeDemo - deserialize cmd:RpcCmd(message=MessageDto(action=p2p, state=100, bytesData=[10, 16, 47, 49, 50, 55, 46, 48, 46, 48, 46, 49, 58, 51, 56, 50, 49, 49, 18, 22, 72, 101, 108, 108, 111, 44, 32, 112, 50, 112, 32, 102, 114, 111, 109, 32, 112, 121, 116, 104, 111, 110], serialData=null), randomKey=random-key-key-random, remoteAddressKey=null)13:15:17.828 [main] INFO com.tony.simple.JavaProtostuffSerializeDemo - deserialize p2p msg:Point2PointMessage(targetAddressKey=/127.0.0.1:38211, message=Hello, p2p from python) io.protostuff使用总结 在java平台可以直接定义普通的POJO而不需要手写proto文件并生成对应的对象文件，仅仅通过其所提供的ProtobufIOUtil或者ProtostuffIOUtil来实现序列化和反序列化即可。 当需要进行跨语言序列化和反序列化时，需要其他语言中编写对应的proto文件并生成对象文件，而在Java中的泛型实例变量则需要进行修改，改成二次序列化的byte数组，方便在Python等语言中进行解析。Java中的序列化也应采用ProtobufIOUtil来实现。此时，Python中可以根据业务类型反序列化成指定的对象，Java中也以该对象来序列化，反过来也是一样的操作。以此来达到的目的是定义MessageDto之后如果需要扩展，不需要修改MessageDto，仅仅需要定义更多的data类型然后赋值给MessageDto.$data。 对比纯protobuf实现的来说，在编码上更加简单，不需要写大量的Any.pack()和Any.unpack()","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://tonyjiangwj.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://tonyjiangwj.github.io/tags/Java/"}]},{"title":"分布式事务TX-LCN原理分析","slug":"分布式事务TX-LCN原理分析","date":"2019-10-17T06:29:11.000Z","updated":"2023-09-09T07:58:50.517Z","comments":true,"path":"2019/10/17/分布式事务TX-LCN原理分析/","link":"","permalink":"https://tonyjiangwj.github.io/2019/10/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1TX-LCN%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"分布式事务框架 TX-LCN原理分析分布式事务的多种形式 XA 基于数据库实现，对数据库是否支持依赖较重。 TCC 主要基于业务代码控制，分为try&#x2F;commit&#x2F;cancel三阶段。业务侵入强，开发和维护难度大。 TXC 基于对SQL的分析，保存SQL执行所影响到的数据快照，在失败后进行回滚。业务侵入低，对SQL兼容要求高，部分SQL不支持。 LCN 通过代理数据库连接对事务进行控制。通过静态代理方式包装原来的数据库连接，根据事务状态控制提交和回滚。业务侵入低，但是因为需要代理数据库连接，必须有本地事务，同时会增加连接占用时间。 一、TX-LCN介绍 LCN名字来源：锁定事务单元（Lock）、确认事务模块状态（Confirm）、通知事务（Notify） TX-LCN是一款事务协调框架，其本身不操作事务，而是基于对事务的协调从而达到事务一致性的效果。 在一个分布式系统下存在多个模块，需要协调完成一次业务，那就存在一次业务事务下可能横跨多种数据源节点的可能。TX-LCN可以解决这样的问题：存在服务模块A、B、C。A模块是MySQL为数据源的服务，B模块是基于Redis为数据源的服务，C模块是基于MongoDB为数据源的服务。若要解决他们的事务一致性就需要针对不同的节点采用不同的方案，并同意协调完成分布式事务的处理。 方案：采用TX-LCN分布式事务框架，则可以将模块A使用LCN模式，B、C采用TCC模式完美解决。 TX-LCN主要分为Tx-Client和Tx-Manager两个模块，TC作为微服务下的依赖，是事务的发起方。TM是独立的服务，是事务的控制方，用于协调事务。 核心步骤如下： 创建事务组 是指在事务发起方开始执行业务代码前先调用TxManager创建事务组对象，然后拿到事务标志GroupId的过程 加入事务组 是指参与方在执行完业务方法后，将该模块的事务信息通知给TxManager的操作 通知事务组 在发起方执行完业务代码后，将发起方执行结果状态通知给TxManager，TxManager根据事务最终状态和事务组的信息来通知相应的参与模块提交或回滚事务，并返回结果给事务发起方。 二、事务协调机制 TX-LCN框架通过方法上配置的事务注解信息来获取当前事务类型，封装事务参数，执行业务代码，清理线程变量等等。具体的事务执行流程则交由DTXServiceExecutor.transationRunning处理，再其内部再根据事务类型和发起方的不同进行不同的处理。 transationRunning中保存事务执行日志、处理事务：执行业务前、执行业务、执行业务后、最后finally。 根据封装的事务参数获取DTXLocalControl顺序调用preBusinessCode、doBusinessCode、onBusinessCodeSuccess or onBusinessCodeError、postBusinessCode。事务发起方的preBusinessCode通过netty调用TxManager创建事务组，参与方则在onBusinessCodeSuccess中加入事务组。 参与方加入事务组后会创建一个延迟线程检测DTX事务状态，通过TxManager查询txException的信息来获取最终的state，同时也可以等待netty通知得到state信息。当超时没有得到通知时才会通过延迟线程得到state，得到通知后会清除对应的延迟线程。最后通过state提交或者回滚事务。 在整个业务代码执行完毕之后，发起方调用postBusinessCode方法，通知事务组最后的执行状态，TxManager服务端获取事务组的状态，并下发事务状态通知到各个模块（通过netty进行发送），并返回最终的state给发起方，发起方再根据state提交或者回滚事务并清理本地事务。 DTXLocalContext\\TracingContext\\TCGlobalContext 共同管理当前线程下事务的一些信息。包括groupId、unitId、txContext等等关键信息 在一个DTX下每个模块中都有且只有一个全局上下文TxContext，当不存在时会进行创建： 如果一个调用链是这样的A-&gt;B-&gt;C 三个都是不同的模块则会为每个模块都构造新的TxContext，保证一个模块一个。 如果三个是两个模块，即A是一个模块，B和C是一个模块根据调用链的情况肯定是C的用B的TxContext。 多个模块事务发起和参与关系通过Tracings来协调，对RPC请求传递Header信息，内容为groupId和appMap，模块在后续处理中通过获取全局上下文获取是否拥有groupId来判断是否是参与方 业务模块A、B、C正常提交当业务全部正常提交时，A最后调用postBusinessCode，告知TxManager通知事务组最后状态，服务端会对B\\C发起通知提交事务。 异常回滚 当A B C 中 C业务异常会直接抛出到B 同时B 抛出到A，最后B、C中直接本地回滚，A得到后也直接回滚，此时并没有任何参与方加入到事务组中，发送的通知也没有作用，因为仅仅成功后调用onBusinessCodeSuccess的才会加入到事务组中去。 当出现异常而A没有成功告知服务端，则会记录txException? 然后B\\C通过延迟检测线程获取最后的事务状态 TODO 详细的异常处理","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://tonyjiangwj.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Java","slug":"Java","permalink":"https://tonyjiangwj.github.io/tags/Java/"}]},{"title":"记一次SQL查询优化","slug":"记一次SQL查询优化","date":"2018-10-31T12:09:58.000Z","updated":"2023-09-09T02:37:32.417Z","comments":true,"path":"2018/10/31/记一次SQL查询优化/","link":"","permalink":"https://tonyjiangwj.github.io/2018/10/31/%E8%AE%B0%E4%B8%80%E6%AC%A1SQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/","excerpt":"","text":"场景：A表数据量大概6万，B表数据量在120万左右，需要在A,B 表中联合查询出符合条件的A表中的数据，不需要B表中的内容，B表中的记录仅仅作为查询条件。 主要关联关系是B表中的object_id保存着A表中的id，表结构大致如下 1234567891011121314151617create table A( id bigint primary key auto_increment, cat_id bigint not null,// 类目id condition1 varchar(100) not null, condition2 varchar(100) not null, .....)// B表中保存着A表的扩展字段，所有动态扩展的字段都保存在B表中，仅通过type_id和cat_id区分create table B( id bigint primary key auto_increment, object_id bigint not null, cat_id bigint not null,// 类目的id attr_id bigint not null,// 属性名称id value varchar(100) not null,// 保存值 .... constraint `out_obj_id` foreign key (`object_id`) reference A(`ID`)// object_id作为外键关联A表中的id) A表作为一个对象的固定属性表，目前的场景是，需要为A表添加动态扩展的属性，但是不去动A表的表结构。所以便有了B表，作为动态扩展属性值保存的表，如果没有扩展的属性在需要查询结果时，只需要常规的SELECT操作，对必要的字段加索引就行。但是现在有了扩展属性，且数据不保存在A表中，也就是当需要对扩展的动态属性作为条件进行查询A表中的记录。 从一开始的想法是通过join联合查询 1234567select A.* from A where A.condition1=&#x27;A条件&#x27; and A.cat_id=$catId$ join B t1 on t1.attr_id=$attr1$ and A.id=t1.object_id and t1.cat_id=$catId$ and t1.value like &#x27;%条件1%&#x27;join B t2 on t2.attr_id=$attr2$ and A.id=t2.object_id and t2.cat_id=$catId$ andt2.value like &#x27;%条件2%&#x27;join B t3 on t3.attr_id=$attr3$ and A.id=t3.object_id and t3.cat_id=$catId$ andt3.value like &#x27;%条件3%&#x27;... 这个方法在数据量较少的时候查询效率还可以，但是当测试数据量变得比较大时，效率便大打折扣，一次查询需要2-3秒之久 后来稍作修改，改成如下，但是效率还是一样没什么差别，甚至更差 12345678select A.* from A where A.condition1=&#x27;A条件&#x27; and A.cat_id=$catId$ AND A.id in(SELECT t1.object_id from (SELECT * FROM B t on t.attr_id=$attr1$ and t1.cat_id=$catId$ and t1.value like &#x27;%条件1%&#x27;) t1join B t2 on t2.attr_id=$attr2$ and t1.object_id=t2.object_id and t2.cat_id=$catId$ andt2.value like &#x27;%条件2%&#x27;join B t3 on t3.attr_id=$attr3$ and t1.object_id=t3.object_id and t3.cat_id=$catId$ andt3.value like &#x27;%条件3%&#x27;...) 后来仔细分析了一下上述两种方法，主要瓶颈都在join的上面了，而in本身效率也就差，对查询效率没有任何优化可言。上面的join主要涉及到的是B表join了多次，因为不同的属性必须在查询一遍，而当一次join就是加一层嵌套循环，效率可想而知的会很差。 后来通过网上查阅资料，发现自己把一个重要的操作EXISTS给忘掉了，在当前场景下，并不需要B表中的任何数据，仅仅将B表中的记录作为条件而已，那么正好可以使用exists来判断是否符合条件。 1234网上示例：select * from A where id in (select id from B);上面的in查询优化成下面的existsselect * from A where exists (select 1 from B where A.id=B.id); exists只返回true or false，当且仅当结果为true时才将结果集保存下来 而且多个exists and链接时，有一个为false那么后面的可以直接抛弃，而不用像join一样结果还需要去循环比较，也就是在这里可以大大的提升效率 最终的SQL优化如下 1234567select A.* from A where A.condition1=&#x27;A条件&#x27; and A.cat_id=$catId$ and exists ( select t1.* from B t1 on t1.attr_id=$attr1$ and A.id=t1.object_id and t1.cat_id=$catId$ and t1.value like &#x27;%条件1%&#x27;) and exists ( select t2.* from B t2 on t2.attr_id=$attr2$ and A.id=t2.object_id and t2.cat_id=$catId$ and t2.value like &#x27;%条件2%&#x27;) and exists (select t3.* from B t3 on t3.attr_id=$attr3$ and A.id=t3.object_id and t3.cat_id=$catId$ and t3.value like &#x27;%条件3%&#x27;) .... 在同等数据量的情况下，将2-3s的查询操作优化到了150ms左右，可以说是质变了 需要注意的是并不是所有情况下都可以使用exists来替代in操作 IN适合于外表大而内表小的情况； EXISTS适合于外表小而内表大的情况。 参考 SQL查询中in和exists的区别分析 mysql join的实现原理及优化思路","categories":[],"tags":[]},{"title":"tar压缩解压缩命令详解","slug":"tar压缩解压缩命令详解","date":"2018-08-13T02:20:06.000Z","updated":"2023-09-09T02:37:32.401Z","comments":true,"path":"2018/08/13/tar压缩解压缩命令详解/","link":"","permalink":"https://tonyjiangwj.github.io/2018/08/13/tar%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"命令详解1234567891011121314-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 查看12tar -tf aaa.tar.gz 在不解压的情况下查看压缩包的内容tar -tvf aa.tar.gz 查看详细内容 压缩1234tar –cvf jpg.tar *.jpg 将目录里所有jpg文件打包成tar.jpgtar –zcvf jpg.tar.gz *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –jcvf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –Zcvf jpg.tar.Z *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z 解压12345tar –xvf file.tar 解压 tar包tar -zxvf file.tar.gz 解压tar.gztar -jxvf file.tar.bz2 解压 tar.bz2tar tar –Zxvf file.tar.Z 解压tar.Ztar -xvf file.tar info.txt 只解压tar包中的info.txt文件 总结12345671、*.tar 用 tar –xvf 解压2、*.gz 用 gzip -d或者gunzip 解压3、*.tar.gz和*.tgz 用 tar –zxvf 解压4、*.bz2 用 bzip2 -d或者用bunzip2 解压5、*.tar.bz2用tar –jxvf 解压6、*.Z 用 uncompress 解压7、*.tar.Z 用tar –Zxvf 解压","categories":[{"name":"脚本命令","slug":"脚本命令","permalink":"https://tonyjiangwj.github.io/categories/%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://tonyjiangwj.github.io/tags/linux/"},{"name":"脚本命令","slug":"脚本命令","permalink":"https://tonyjiangwj.github.io/tags/%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"}]},{"title":"常用命令小计","slug":"常用命令小计","date":"2018-08-09T07:32:04.000Z","updated":"2023-09-09T06:27:41.959Z","comments":true,"path":"2018/08/09/常用命令小计/","link":"","permalink":"https://tonyjiangwj.github.io/2018/08/09/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%A1/","excerpt":"记录工作中用到的一些比较实用的命令，包括Windows和Linux下的。持续更新中","text":"记录工作中用到的一些比较实用的命令，包括Windows和Linux下的。持续更新中 Maven命令常用基本命令1234567891011121314151617181920212223242526创建maven项目：mvn archetype:create指定 group： -DgroupId=packageName指定 artifact：-DartifactId=projectName创建web项目：-DarchetypeArtifactId=maven-archetype-webapp创建maven项目：mvn archetype:generate验证项目是否正确：mvn validatemaven 打包：mvn package只打jar包：mvn jar:jar生成源码jar包：mvn source:jar产生应用需要的任何额外的源代码：mvn generate-sources编译源代码： mvn compile编译测试代码：mvn test-compile运行测试：mvn test运行检查：mvn verify清理maven项目：mvn clean生成eclipse项目：mvn eclipse:eclipse清理eclipse配置：mvn eclipse:clean生成idea项目：mvn idea:idea安装项目到本地仓库：mvn install发布项目到远程仓库：mvn deploy在集成测试可以运行的环境中处理和发布包：mvn integration-test显示maven依赖树：mvn dependency:tree显示maven依赖列表：mvn dependency:list分析maven依赖情况：mvn dependency:analyze下载依赖包的源码：mvn dependency:sources安装本地jar到本地仓库：mvn install:install-file -DgroupId=packageName -DartifactId=projectName -Dversion=version -Dpackaging=jar -Dfile=path maven 命令的格式为 mvn [plugin-name]:[goal-name]，可以接受的参数如下， 123456-D 指定参数，如 -Dmaven.test.skip(=true可选项) 跳过单元测试；-P 指定 Profile 配置，可以用于区分环境；-e 显示maven运行出错的信息；-o 离线执行命令,即不去远程仓库更新包；-X 显示maven允许的debug信息；-U 强制去远程更新snapshot的插件或依赖，默认每天只更新一次。 maven分析依赖情况，通过该命令可以快速定位依赖情况，然后通过在pom里面添加exclusion排除冲突的依赖 1234mvn dependency:tree -Dverbose -Dincludes=groupId:artifactId:version# -Dverbose显示详细信息# -Dincludes指定包含的包，可以用*匹配如-Dincludes=org.apache.*:*# -Dexcludes排除包，类似于includes web项目相关命令 启动tomcat：mvn tomcat:run 启动jetty：mvn jetty:run 运行打包部署：mvn tomcat:deploy 撤销部署：mvn tomcat:undeploy 启动web应用：mvn tomcat:start 停止web应用：mvn tomcat:stop 重新部署：mvn tomcat:redeploy 部署展开的war文件：mvn war:exploded tomcat:exploded Linux下自动化脚本根据输入进程描述自动杀死进程 有时候要杀死tomcat进程通常都是分步骤找到pid再kill 1234$ ps -ef | grep descemail 6762 1 0 Aug07 ? 00:01:03 processDesc#得到上述pid 6762然后kill$ kill -s 9 6762 以上操作往往效率比较低，现在可以通过awk配合ps -ef | grep desc 命令自动获取pid并杀死进程，可以将下述代码保存为可执行文件，在后续直接执行并输入进程描述来达成自动杀死进程的目的。 123456789101112131415161718192021222324252627282930313233#!/bin/bashkill_func() &#123; #赋值输入的进程描述信息 processDesc=$1 #得到进程描述信息匹配到的进程数量，如果不唯一则退出，防止误杀 PCOUNT=$(ps -ef | grep $processDesc | grep -v grep | awk &#x27;END&#123;print NR&#125;&#x27;) if [ $PCOUNT -gt 1 ]; then echo &quot;for input [$processDesc] found $PCOUNT processes, pid is not unique,please recheck your input.&quot; exit elif [ $PCOUNT -eq 0 ]; then echo &quot;process $processDesc not exist&quot; exit fi #得到进程PID然后执行kill PID=$(ps -ef |grep $processDesc | grep -v grep | awk &#x27;&#123;printf $2&#125;&#x27;) if [ $? -eq 0 ]; then echo &quot;process id:$PID&quot; else echo &quot;process $processDesc not exist&quot; exit fi kill -9 $&#123;PID&#125; if [ $? -eq 0 ];then echo &quot;kill $processDesc success&quot; else echo &quot;kill $processDesc fail&quot; fi&#125;#输入进程描述信息echo &quot;please input process descripe info&quot;read inputkill_func $inputecho &quot;done!&quot; ##Linux下常用命令 查看当前目录下各个文件夹的大小 du -h --max-depth=1 -h命令用来人性化展示容量单位 达到1000k用m 1000m用G,依次类推 查看磁盘总体用量 df -h","categories":[],"tags":[{"name":"脚本命令","slug":"脚本命令","permalink":"https://tonyjiangwj.github.io/tags/%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"name":"Shell","slug":"Shell","permalink":"https://tonyjiangwj.github.io/tags/Shell/"}]},{"title":"记录几个和Safari有关的坑","slug":"记录几个和Safari有关的坑","date":"2018-08-02T05:35:58.000Z","updated":"2018-08-11T01:23:14.654Z","comments":true,"path":"2018/08/02/记录几个和Safari有关的坑/","link":"","permalink":"https://tonyjiangwj.github.io/2018/08/02/%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AA%E5%92%8CSafari%E6%9C%89%E5%85%B3%E7%9A%84%E5%9D%91/","excerpt":"","text":"记录几个和Safari有关的坑前段时间用vue开发移动端应用遇到了几个问题，现在记录一下 第一个是和a标签有关的 第二个和date format有关 1.a标签的坑 这是一个很简单错误，但是愣是让我找了半天才找到； 1&lt;a href=&quot;#&quot; @click=&quot;$router.go(-1)&quot;&gt;返回&lt;/a&gt; a标签的click返回上级的动作，代码如上所示； 项目中使用了vue-router中router.go(-1)来跳转，一开始在PC和安卓模拟器上试了各种跳转完全没有问题，后来用iPhone来测试之后愣是怎么点都没用反应，期间我试了原生的history.back()&#x2F;history.go(-1)都没用作用。然后去google找啊找，找到的内容有说Safari不支持History的操作，我信了，然后看的云里雾里，还是没搞懂为什么不支持，如果不支持那其他应用是怎么跳转的，而且以前的项目也都是用history来操作返回的呀，没见过反应说Safari不能使用呀。然后继续在google上找啊找，找到很多都是如下所说的： 12解决方法很简单！加上return false; 就可以了&lt;a href=&quot;#&quot; class=&quot;back&quot; onclick=&quot;javascript: window.history.go(-1);return false;&quot;&gt;&lt;/a&gt; 于是我就按他说的做了，嗯，确实可以跳转了，但是这么写也太不优雅了，而且我把javascript: window.history.go(-1);return false;写到function里面通过@click触发之后还是失败，甚是奇怪，这是为什么呢 到底为啥，这时我已经自暴自弃了。本着钻牛角尖的精神我还是不想用上述这么丑的操作，在每个标签里面都写js代码不仅累，而且维护起来也麻烦。在不知道各种试了多久之后，我才恍然醒悟，我以前写a标签里面href都是写成href=&quot;javascript:void(0);&quot;的，而这个项目直接复制的美工提供的静态代码，没有注意到他里面写的是href=&quot;#&quot;，而且google找到的这个解决办法里面也是写成href=&quot;#&quot;的。于是我将href=&quot;#&quot;改成了href=&quot;javascript:void(0);&quot;，然后重新用手机试了一下发现果然是这里的问题。那么为什么在其他平台的浏览器能行，但是在Safari上就不行，实在是想不通，私以为Safari认为点击之后就是跳到#，也就是向上滚动到锚点#top了，后续的History跳转都不会去执行。那么同时，为什么改成href=&quot;javascript:void(0);&quot;配合function就能和直接在html代码里面嵌入js代码达到一样的效果呢？继续google发现有说法是&lt;a href=&quot;#&quot; onclick=&quot;javascript:return false;&quot;&gt;和&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;back()&quot;&gt;是等价的，这么一说好像确实有道理，毕竟实践的结果确实是等价的。然后他们又说不推荐后者的写法，给出的原因是IE6什么的有问题，看到这里我喷了，IE6？适配？不存在的！我还是按后者写吧，更简洁而且click事件写在function里面方便维护扩展其他功能。同时也有说法是写成javascript:;也能达到同样的效果，这就见仁见智吧我觉得五五开，都可以。 所以这个困扰我大半天的bug，就这么解决了。冷漠脸。感觉浪费了大把青春啊。果然还是因为姿势水平不够，需要更多的积累。 2.Safari里面的Date Format问题除了上述那个困扰我那么久的问题，另一个就是我在其他平台上都正常的new Date()日期格式化，在Safari里面格式化出来的是invalid date。在后台日期都是被格式化成yyyy-MM-dd HH:mm:ss格式的，但是前台显示不需要时间只需要日期，因为显示的同时要通过时间选择控件修改这个日期，所以没有用substring字符串截取方式直接获得日期，转而在前端用new Date(dateStr)转成Date再通过通用方法格式化成yyyy-MM-dd格式的字符串。但是在Safari里，界面上显示的都成了Nan-Nan-Nan，通过alert调试发现new Date()得到的是invalid date，但是在电脑上又是正常的。基于上一个问题的经验，我马上去google了一下Safari中日期格式化的问题，果不其然，YYYY-MM-DD格式是包含在ECMAScript标准中的，只是Safari没有实现，没有实现。。。竟然还能这样。那既然知道为什么了，解决起来也就很简单了，只需要将-改为/再new Date format一下就行了，new Date(dateStr.replace(/-/g, &#39;&#39;))妥妥的解决。","categories":[{"name":"前端","slug":"前端","permalink":"https://tonyjiangwj.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://tonyjiangwj.github.io/tags/jQuery/"},{"name":"表格","slug":"表格","permalink":"https://tonyjiangwj.github.io/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"表单验证","slug":"表单验证","permalink":"https://tonyjiangwj.github.io/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-08-01T16:00:00.000Z","updated":"2018-08-11T01:23:14.651Z","comments":true,"path":"2018/08/02/hello-world/","link":"","permalink":"https://tonyjiangwj.github.io/2018/08/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://tonyjiangwj.github.io/tags/hexo/"}]}],"categories":[{"name":"脚本命令","slug":"脚本命令","permalink":"https://tonyjiangwj.github.io/categories/%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"name":"前端","slug":"前端","permalink":"https://tonyjiangwj.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://tonyjiangwj.github.io/tags/hexo/"},{"name":"Shell","slug":"Shell","permalink":"https://tonyjiangwj.github.io/tags/Shell/"},{"name":"Java","slug":"Java","permalink":"https://tonyjiangwj.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"https://tonyjiangwj.github.io/tags/Android/"},{"name":"后端","slug":"后端","permalink":"https://tonyjiangwj.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"linux","slug":"linux","permalink":"https://tonyjiangwj.github.io/tags/linux/"},{"name":"脚本命令","slug":"脚本命令","permalink":"https://tonyjiangwj.github.io/tags/%E8%84%9A%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"name":"jQuery","slug":"jQuery","permalink":"https://tonyjiangwj.github.io/tags/jQuery/"},{"name":"表格","slug":"表格","permalink":"https://tonyjiangwj.github.io/tags/%E8%A1%A8%E6%A0%BC/"},{"name":"表单验证","slug":"表单验证","permalink":"https://tonyjiangwj.github.io/tags/%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"}]}